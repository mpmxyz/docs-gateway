= Data Chaching Policy Template
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

Use the data chaching policy template as an example of how to xref:policies-pdk-configure-features.adoc#share-data-between-workers-and-caching.adoc[configure policy caching].

== Before You Begin

. xref:polices-pdk-prequisites.adoc[]

== Policy Use Case

To better understand how to implement a custom policy, imagine an example "The Awesome Store" company that is in the business of acquiring and selling one of a kind antiques and other items. The Awesome Store needs to track the precedence of each item of its collection and who it sells to. 

To track all the inventory movement the company has an API that takes care of it. But since the company is moving from a local business to a franchise they need to expose said API on the Internet so all the store managers can access it. To do this they need to protect the API with an authentication layer. They hired “Ripley 2000” as their Identity Management provider.

Many Identity providers comply with the OpenId standards, and provide an introspection endpoint to validate generated Oauth2 tokens. The rfc7662 specifies the request and responses of the introspection endpoint and states that an authentication mechanism to hit said endpoint is required. Unfortunately the rfc does not specify which authentication mechanism should be used, so there is no universal way to interact with them. 

The introspection endpoint provided by “Ripley 2000” requires a custom token to be sent through the Authorization header in the request. Therefore The Awesome Store needs to develop a custom policy to be able to validate tokens.

The policy will read the token from the incoming request and send it to the introspection endpoint with the required authorization header and validate if the token is active. If any validation error occurs the policy will log what happened and reject the incoming request.

To better reuse the policy in the future, the policy should be able to configure the introspection endpoint url, where to extract the Oauth2 token from the request, and the custom authorization value. 
 

== Implement the Policy

To implement the policy:

. xref:policies-pdk-create-project.adoc[Create a new policy project].
. Replace the `src/gcl.yaml` file with the following snippet:
+
.Expand to view the `yaml` snippet.
[%collapsible]
====
[source, yaml]
----
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: Extension
metadata:
  labels:
    title: awesome-oauth2-validation
    category: Custom
spec:
  extends:
    - name: extension-definition
  properties:
    tokenExtractor:
      type: string
      format: dataweave
      default: "#[dw::core::Strings::substringAfter(attributes.headers['Authorization'], 'Bearer ')]"
    upstream:
      type: string
    host:
      type: string
    path:
      type: string
    authorization:
      type: string
  required:
    - tokenExtractor
    - upstream
    - host
    - path
    - authorization
----
====
+
The `yaml` snippet defines the following configuration parameters:
+
* `max_cached_values`: The maximum number of response to cache
* `start_hour`: The start of non-business hours
* `end_hour`: The end of non-business hours

. Run the `build-asset-files` command to propagate the changes to the `src/generated/config.rs` rust file and the JSON schema for the UI:
+
[source,cmd]
----
make build-asset-files
----

. Add the `chrono` Rust library to the `cargo.toml` file:
+
[source,toml]
----
[dependencies]
...
serde_urlencoded = "0.7.0"
----

. Replace the `src/lib.rs` with the following Rust file:
+
.Expand to view the Rust file.
[%collapsible]
====
[source,rust]
----
// Copyright 2023 Salesforce, Inc. All rights reserved.
mod generated;

use anyhow::Result;

use pdk::api::hl::*;

use crate::generated::config::Config;
use serde::Deserialize;
use std::time::{SystemTime, UNIX_EPOCH};

/// We define our custom errors to handle them in an unified way
pub enum FilterError {
    Unexpected,
    NoToken,
    InactiveToken,
    ExpiredToken,
    NotYetActive,
    ClientError(HttpClientError),
    NonParsableIntrospectionBody(serde_json::Error),
}

/// This struct is used to parse the response of the rfc7662 compliant introspection endpoint
#[derive(Deserialize)]
pub struct IntrospectionResponse {
    pub active: bool,
    pub exp: Option<u64>,
    pub nbf: Option<u64>,
}

/// In this function we execute send the request to the introspection endpoint and parse the response
async fn introspect_token(
    token: &str,
    config: &Config,
    client: HttpClient,
) -> Result<IntrospectionResponse, FilterError> {
    // Encode the token for the request payload
    let body =
        serde_urlencoded::to_string([("token", token)]).map_err(|_| FilterError::Unexpected)?;

    // Set the content type and add the configured authentication header
    let headers = vec![
        ("content-type", "application/x-www-form-urlencoded"),
        ("Authorization", config.authorization.as_str()),
    ];

    // Execute the request with the configured upstream and await the response
    let response = client
        .request(config.upstream.as_str(), config.host.as_str())
        .path(config.path.as_str())
        .headers(headers)
        .body(body.as_bytes())
        .post()
        .await
        .map_err(FilterError::ClientError)?;

    // Parse the response from the backend
    if response.status_code() == 200 {
        serde_json::from_slice(response.body())
            .map_err(FilterError::NonParsableIntrospectionBody)
    } else {
        Err(FilterError::InactiveToken)
    }
}

/// This function will parse the token, send it to the introspection endpoint and validate its response.
async fn do_filter(request: impl HeadersHandler, config: &Config, client: HttpClient) -> Result<(), FilterError> {

    // Extract the token from the request
    let result = config
        .token_extractor
        .resolve_on_headers(&request)
        .map_err(|_| FilterError::NoToken)?;

    let token = result.as_str().ok_or(FilterError::NoToken)?;

    // Send the token to the introspection endpoint
    let response = introspect_token(token, config, client).await?;

    // Obtain the current time
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map_err(|_| FilterError::Unexpected)?
        .as_secs();

    // Validate if the token is active
    if !response.active {
        return Err(FilterError::InactiveToken);
    }

    // Validate if the token has expired
    if response.exp.map(|exp| now > exp).unwrap_or_default() {
        return Err(FilterError::ExpiredToken);
    }

    // Validate if the token has started its validity period
    if response.nbf.map(|nbf| now < nbf).unwrap_or_default() {
        return Err(FilterError::NotYetActive);
    }

    // Validation succeeded!
    Ok(())
}

/// Generate a standard early response that indicates the token validation failed.
fn unauthorized_response() -> Flow<()> {
    Flow::Break(Response::new(401)
        .with_headers(vec![("WWW-Authenticate".to_string(), "Bearer realm=\"oauth2\"".to_string())]))
}

/// Generate a standard early response that indicates that there was an unexpected error
fn server_error_response() -> Flow<()> {
    Flow::Break(Response::new(500))
}

/// We define this filter function that works as a wrapper for the real filter function,
/// this allows us to simplify the error handling.
async fn request_filter(state: RequestState, client: HttpClient, config: &Config) -> Flow<()> {
    let state = state.into_headers_state().await;

    match do_filter(state, config, client).await {
        Ok(_) => Flow::Continue(()),
        Err(err) => {
            match err {
                FilterError::Unexpected => {
                    logger::warn!("Unexpected error occurred while processing the request.");
                    server_error_response()
                }
                FilterError::NoToken => {
                    logger::debug!("No authorization token was provided.");
                    unauthorized_response()
                }
                FilterError::InactiveToken => {
                    logger::debug!("Token is marked as inactive by the introspection endpoint.");
                    unauthorized_response()
                }
                FilterError::ExpiredToken => {
                    logger::debug!("Expiration time on the token has been exceeded.");
                    unauthorized_response()
                }
                FilterError::NotYetActive => {
                    logger::debug!(
                        "Token is not yet valid, since time set in the nbf claim has not been reached."
                    );
                    unauthorized_response()
                }
                FilterError::ClientError(err) => {
                    logger::warn!(
                        "Error sending the request to the introspection endpoint. {:?}.",
                        err
                    );
                    server_error_response()
                }
                FilterError::NonParsableIntrospectionBody(err) => {
                    logger::warn!(
                        "Error parsing the response from the introspection endpoint. {}.",
                        err
                    );
                    server_error_response()
                }
            }
        }
    }
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();
    launcher.launch(on_request(|request, client| request_filter(request, client, &config))).await?;
    Ok(())
}

----
====

. Read the function documentation provided in the Rust file.
. Edit `src/lib.rs` to fit your needs.

== Test the Policy

To test the policy:

. Run the `build` command to compile the policy:
+
[source,ssh]
----
make build
----
+
For more information about compiling policies, see xref:policies-pdk-compile-policies.adoc[].
. Configure the ‘test/config/api.yaml’ as follows:
+
.Expand to view the `yaml` configuration example.
[%collapsible]
====
[source,yaml]
----
# Copyright 2023 Salesforce, Inc. All rights reserved.
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: ApiInstance
metadata:
  name: ingress-http
spec:
  address: http://0.0.0.0:8081
  services:
    upstream:
      address: http://backend
      routes:
        - config:
            destinationPath: /anything/echo/
  policies:
    - policyRef:
        name: awesome-caching-v1-0-impl
      config:
        max_cached_values: 10
        start_hour: 18
        end_hour: 10
----
====

. Configure a Flex Gateway instance to debug the policy.
+
For more information, see xref:policies-pdk-debug-local.adoc[].

. Run the `run` command to start the Flex Gateway instance:
+
[source,ssh]
----
make run
----
+
NOTE: The `run` command starts a Flex Gateway instance inside a Docker container. By default, Docker containers use UTC as the local time. 

. Send requests to the Flex Gateway. Ues the following command as an example:
+
[source,ssh]
----
curl http://127.0.0.1:8081/catalog/1 -H "cache_check: cache_value"
----
+
If the request is sent during the configured non-business hours, the response contains the original header. If the request is sent during the configured business hours, the response is empty.

. Adjust the configured non-business hours, to view both responses.