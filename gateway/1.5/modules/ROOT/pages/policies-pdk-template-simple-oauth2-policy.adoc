= Simple OAuth 2.0 Validation Policy Template
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

Use the simple OAuth 2.0 validation policy policy as an example of how you create a policy that makes xref:policies-pdk-configure-features.adoc#perform-an-http-call[HTTP requests].


== Before You Begin

. xref:policies-pdk-prerequisites.adoc[]

== Policy Use Case

An antique store that buys and sells items needs to track the stock of each item in its collection and who buys it. To track the inventory movement, the company uses an API. 

Because the company is franchising, they need to expose the API on the internet for all the store managers to access. To do this, they must protect the API with an authentication layer. 

For their identity management provider, they hired the “Ripley 2000” Authentication service.

Like many other identity providers, Ripley 2000 complies with OpenId standards and provides an introspection endpoint to validate OAuth 2.0 tokens. 

The RFC 7662: Token Introspection extension specifies the request and response format of the introspection endpoint and states that an authentication mechanism is required. However the RFC 7662 does not specify which authentication mechanism should be used.

The introspection endpoint provided by “Ripley 2000” requires a custom token to be sent in an authorization header with the request. The policy reads the token from the incoming request and sends it to the introspection endpoint to validate if the token is active. If any validation error occur, the policy logs the error and rejects the incoming request.

To reuse the policy, the introspection endpoint url, how to extract the OAuth 2.0 token, and the custom authorization values are configurable. 
 

== Implement the Policy

To implement the policy:

. xref:policies-pdk-create-project.adoc[Create a new policy project].
. Replace the `src/gcl.yaml` file with the following snippet:
+
.Expand to view the `yaml` snippet.
[%collapsible]
====
[source, yaml]
----
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: Extension
metadata:
  labels:
    title: awesome-oauth2-validation
    category: Custom
spec:
  extends:
    - name: extension-definition
  properties:
    tokenExtractor:
      type: string
      format: dataweave
      default: "#[dw::core::Strings::substringAfter(attributes.headers['Authorization'], 'Bearer ')]"
    upstream:
      type: string
    host:
      type: string
    path:
      type: string
    authorization:
      type: string
  required:
    - tokenExtractor
    - upstream
    - host
    - path
    - authorization
----
====
+
The `yaml` snippet defines the following configuration parameters:
+
* `tokenExtractor`: DataWeave expression that extracts the token from the request
* `upstream`: URL of the upstream service the introspection request is sent
* `host`: Introspection request host
* `path`: Introspection request path
* `authorization`: Authorization to interact with the introspection endpoint.

. Run the `build-asset-files` command to propagate the changes to the `src/generated/config.rs` Rust file and the JSON schema for the UI:
+
[source,cmd]
----
make build-asset-files
----

. Add the `serde_urlencoded` Rust library to the `cargo.toml` file:
+
[source,toml]
----
[dependencies]
...
serde_urlencoded = "0.7.0"
----

. Replace the `src/lib.rs` with the following Rust file:
+
.Expand to view the Rust file.
[%collapsible]
====
[source,rust]
----
// Copyright 2023 Salesforce, Inc. All rights reserved.
mod generated;

use anyhow::Result;

use pdk::api::hl::*;

use crate::generated::config::Config;
use serde::Deserialize;
use std::time::{SystemTime, UNIX_EPOCH};

/// Defines the custom errors to handle them in an unified way
pub enum FilterError {
    Unexpected,
    NoToken,
    InactiveToken,
    ExpiredToken,
    NotYetActive,
    ClientError(HttpClientError),
    NonParsableIntrospectionBody(serde_json::Error),
}

/// This struct parses the response of the rfc7662 compliant introspection endpoint
#[derive(Deserialize)]
pub struct IntrospectionResponse {
    pub active: bool,
    pub exp: Option<u64>,
    pub nbf: Option<u64>,
}

/// Sends the request to the introspection endpoint and parse the response
async fn introspect_token(
    token: &str,
    config: &Config,
    client: HttpClient,
) -> Result<IntrospectionResponse, FilterError> {
    // Encodes the token for the request payload
    let body =
        serde_urlencoded::to_string([("token", token)]).map_err(|_| FilterError::Unexpected)?;

    // Sets the content type and add the configured authentication header
    let headers = vec![
        ("content-type", "application/x-www-form-urlencoded"),
        ("Authorization", config.authorization.as_str()),
    ];

    // Executes the request with the configured upstream and await the response
    let response = client
        .request(config.upstream.as_str(), config.host.as_str())
        .path(config.path.as_str())
        .headers(headers)
        .body(body.as_bytes())
        .post()
        .await
        .map_err(FilterError::ClientError)?;

    // Parses the response from the backend
    if response.status_code() == 200 {
        serde_json::from_slice(response.body())
            .map_err(FilterError::NonParsableIntrospectionBody)
    } else {
        Err(FilterError::InactiveToken)
    }
}

/// Parses the token, sends it to the introspection endpoint, and validate the response
async fn do_filter(request: impl HeadersHandler, config: &Config, client: HttpClient) -> Result<(), FilterError> {

    // Extracts the token from the request
    let result = config
        .token_extractor
        .resolve_on_headers(&request)
        .map_err(|_| FilterError::NoToken)?;

    let token = result.as_str().ok_or(FilterError::NoToken)?;

    // Sends the token to the introspection endpoint
    let response = introspect_token(token, config, client).await?;

    // Obtains the current time
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map_err(|_| FilterError::Unexpected)?
        .as_secs();

    // Validates if the token is active
    if !response.active {
        return Err(FilterError::InactiveToken);
    }

    // Validates if the token has expired
    if response.exp.map(|exp| now > exp).unwrap_or_default() {
        return Err(FilterError::ExpiredToken);
    }

    // Validates if the token has started its validity period
    if response.nbf.map(|nbf| now < nbf).unwrap_or_default() {
        return Err(FilterError::NotYetActive);
    }

    // Validation succeeded!
    Ok(())
}

/// Generates a standard early response that indicates the token validation failed
fn unauthorized_response() -> Flow<()> {
    Flow::Break(Response::new(401)
        .with_headers(vec![("WWW-Authenticate".to_string(), "Bearer realm=\"oauth2\"".to_string())]))
}

/// Generates a standard early response that indicates that there was an unexpected error
fn server_error_response() -> Flow<()> {
    Flow::Break(Response::new(500))
}

/// Defines a filter function that works as a wrapper for the real filter function that enables simplified error handling
async fn request_filter(state: RequestState, client: HttpClient, config: &Config) -> Flow<()> {
    let state = state.into_headers_state().await;

    match do_filter(state, config, client).await {
        Ok(_) => Flow::Continue(()),
        Err(err) => {
            match err {
                FilterError::Unexpected => {
                    logger::warn!("Unexpected error occurred while processing the request.");
                    server_error_response()
                }
                FilterError::NoToken => {
                    logger::debug!("No authorization token was provided.");
                    unauthorized_response()
                }
                FilterError::InactiveToken => {
                    logger::debug!("Token is marked as inactive by the introspection endpoint.");
                    unauthorized_response()
                }
                FilterError::ExpiredToken => {
                    logger::debug!("Expiration time on the token has been exceeded.");
                    unauthorized_response()
                }
                FilterError::NotYetActive => {
                    logger::debug!(
                        "Token is not yet valid, since time set in the nbf claim has not been reached."
                    );
                    unauthorized_response()
                }
                FilterError::ClientError(err) => {
                    logger::warn!(
                        "Error sending the request to the introspection endpoint. {:?}.",
                        err
                    );
                    server_error_response()
                }
                FilterError::NonParsableIntrospectionBody(err) => {
                    logger::warn!(
                        "Error parsing the response from the introspection endpoint. {}.",
                        err
                    );
                    server_error_response()
                }
            }
        }
    }
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();
    launcher.launch(on_request(|request, client| request_filter(request, client, &config))).await?;
    Ok(())
}
----
====

. Read the function documentation provided in the Rust file.
. Edit `src/lib.rs` to fit the needs of your policy.

== Test the Policy

To test the policy:

. Add a `Service` resource defining your introspection service in the `test/config` folder.
+
For example, the following resource defines the Ripley 2000 service from the use case:
+
[source,yaml]
----
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: Service
metadata:
    name: ripley2000
spec:
    address: https://ripley2000:5001
----
+
[NOTE]
====
If you don't have a introspection service, you can set the address to `\http://host.docker.internal:5001` and create a mock service by using netcat. Use the following mock service response as an example:

[source,ssh]
----
echo -e 'HTTP/1.1 200 OK\n\n {"active":true}' | nc -l 5001
----
====

. Run the `build` command to compile the policy:
+
[source,ssh]
----
make build
----
+
For more information about compiling policies, see xref:policies-pdk-compile-policies.adoc[].
. Configure the `test/config/api.yaml` replacing the Ripley 2000 examples with your authentication service details:
+
.Expand to view the `yaml` configuration example.
[%collapsible]
====
[source,yaml]
----
# Copyright 2023 Salesforce, Inc. All rights reserved.
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: ApiInstance
metadata:
  name: ingress-http
spec:
  address: http://0.0.0.0:8081
  services:
    upstream:
      address: http://backend
      routes:
        - config:
            destinationPath: /anything/echo/
  policies:
    - policyRef:
        name: awesome-oauth-2-validation-v1-0-impl
      config:
        tokenExtractor: "#[dw::core::Strings::substringAfter(attributes.headers['Authorization'], 'Bearer ')]"
        upstream: ripley2000.default.svc
        host: ripley:5001
        path: /authorize
        authorization: Basic dXNlcjpwYXNz
----
====

. Configure a Flex Gateway instance to debug the policy.
+
For more information, see xref:policies-pdk-debug-local.adoc[].

. Run the `run` command to start the Flex Gateway instance:
+
[source,ssh]
----
make run
----

. Send requests to Flex Gateway by using the following command as example:
+
[source,ssh]
----
curl http://127.0.0.1:8081 -H "Authorization: Bearer <your.oauth2.token>"
----
+
Test both valid and invalid tokens.
