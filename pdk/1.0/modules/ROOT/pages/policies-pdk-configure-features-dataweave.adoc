= Using DataWeave Expressions
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

NOTE: To view an example policy project that uses DataWeave expressions, see https://github.com/mulesoft/pdk-custom-policy-examples/blob/main/query/README.md[Query Policy Example^].

If input DataWeave expression parameter is valid, the policy parses the expression and transforms it into a `pdk::script::Script` expression. To obtain the result of the script:

. Create an evaluator.
. Call the binding function for each parameter defined in schema definition:
+
* `vars`: Call the `bind_vars` method for each of the policy's `vars`. After all of `vars` are bound, the evaluator tries to solve the expression. If the expression contains `vars` other than the ones defined in the schema, they resolve to `null`.
* `attributes`: Call the `bind_attributes` methods with an implementation of the `AttributesBinding` trait. PDK provides a implementation of this trait by instantiating a new `HandlerAttributesBinding` for each `RequestHeaderState`, `RequestHeaderState`, and response of an xref:policies-pdk-configure-features-http-request.adoc[HTTP call].
* `authentication`: Call the method `bind_authentication` with an implementation of the trait `AuthenticationBinding`. PDK provides an implementation of this trait for `AuthenticationData`. To inject authentication information into your policy, see xref:policies-pdk-configure-features-inject-parameters.adoc#authentication[Inject Authentication Inforamaion].
* `payload`: Call the `bind_payload` method with an implementation of the trait `PayloadBinding`. PDK provides an implementation of this trait for `RequestBodyState`, `ResponseBodyState`, and the response of an xref:policies-pdk-configure-features-http-request.adoc[HTTP call].
+
[NOTE]
====
You only need to call the methods for the bindings that are defined in the schema definition. For example, if the `attributes` binding is not used, you don't need to call the `bind_attributes` method.

To learn more about defining DataWeave expressions, see xref:policies-pdk-create-schema-definition.adoc#dataweave-expressions[DataWeave Expressions].
====

. After you bind all expression variables, you can obtain the result by calling the `eval` method.

[[example-evaluator-code]]
== Example Evaluator Code

For example, the DataWeave expression in the following policy schema definition:

[source,yaml]
----
apiVersion: gateway.mulesoft.com/v1alpha1
kind: Extension
metadata:
 labels:
   title: jwt-auth
   category: Custom
spec:
 extends:
   - name: extension-definition
     namespace: default
 properties:
   tokenExtractor:
     type: string
     format: dataweave
     default: "#[vars.myVar]"
     bindings:
       payload:
         mimeType: text
       attributes: true
       authentication: true
       vars:
         - myVar
 required:
   - tokenExtractor

----

Can be evaluated with this Rust snippet:

[source,rust]
----
// Copyright 2023 Salesforce, Inc. All rights reserved.
mod generated;


use anyhow::Result;


use crate::generated::config::Config;
use pdk::hl::authentication::{Authentication, AuthenticationHandler};
use pdk::logger::info;
use pdk::hl::*;
use pdk::script::{Evaluator, HandlerAttributesBinding, Value};


async fn request_filter(
   state: RequestState,
   stream: StreamProperties,
   auth: Authentication,
   mut evaluator: Evaluator<'_>,
) {
   evaluator.bind_vars("myVar", "myVal");

   evaluator.bind_authentication(&auth.authentication());

   let state = state.into_headers_state().await;
   evaluator.bind_attributes(&HandlerAttributesBinding::new(state.handler(), &stream));

   let state = state.into_body_state().await;
   evaluator.bind_payload(&state);

   if let Ok(value) = evaluator.eval() {
       match value {
           Value::Null => info!("value was null!"),
           Value::Bool(val) => info!("value was Bool: {val}"),
           Value::Number(val) => info!("value was Number: {val}"),
           Value::String(val) => info!("value was String: {val}"),
           Value::Array(val) => info!("value was Array: {val:?}"),
           Value::Object(val) => info!("value was Object: {val:?}"),
       }
   }
}


#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
   let config: Config = serde_json::from_slice(&bytes)?;


   launcher
       .launch(on_request(|request, stream, auth| {
           request_filter(request, stream, auth, config.token_extractor.evaluator())
       }))
       .await?;
   Ok(())
}
----

NOTE: This policy uses the `#[attributes.remoteAddress]` variable, which is useful for rate limiting.

== DefaultBindings

If you don't require custom bindings in your DataWeave expression, you can simplify your code by using the `DefaultBindings` object provided by PDK. The `DefaultBindings` object that wraps the evaluator and transforms the methods to simplify the resolution of the script.

For example, to solve the script in <<example-evaluator-code>>, the code needed to inject the `StreamProperties` and `Authentication` parameters. PDK provides these parameters in the `DefaultBindings` object. 

`DefaultBindings` requires you to expose the following methods to bind different pieces of data before evaluating the Script:

[source,rust]
----
fn bind_vars<K: IntoValue>(&mut self, name: &str, value: K)

fn bind_headers(&mut self, binding: &dyn HeadersHandler)

fn bind_payload(&mut self, binding: &dyn PayloadBinding)

fn bind_http_client_response(&mut self, binding: &HttpClientResponse)

fn bind_authentication(&mut self)
----

Given the parameters used in the schema definition from <<example-evaluator-code>>, the expression can be evaluated by using `DefaultBindings` as shown in this Rust snippet:


[source,rust]
----
// Copyright 2023 Salesforce, Inc. All rights reserved.
mod generated;
use anyhow::Result;


use crate::generated::config::Config;
use pdk::logger::info;
use pdk::hl::*;
use pdk::script::{DefaultBindings, Value};


async fn request_filter(state: RequestState, bindings: DefaultBindings, config: &Config) {
   let mut evaluator = bindings.evaluator(&config.token_extractor);
   evaluator.bind_vars("myVar", "myVal");


   evaluator.bind_authentication();


   let state = state.into_headers_state().await;
   evaluator.bind_headers(state.handler());


   let state = state.into_body_state().await;
   evaluator.bind_payload(&state);


   if let Ok(value) = evaluator.eval() {
       match value {
           Value::Null => info!("value was null!"),
           Value::Bool(val) => info!("value was Bool: {val}"),
           Value::Number(val) => info!("value was Number: {val}"),
           Value::String(val) => info!("value was String: {val}"),
           Value::Array(val) => info!("value was Array: {val:?}"),
           Value::Object(val) => info!("value was Object: {val:?}"),
       }
   }
}


#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
   let config: Config = serde_json::from_slice(&bytes)?;


   launcher
       .launch(on_request(|request, bindings| {
           request_filter(request, bindings, &config)
       }))
       .await?;
   Ok(())
}
----

== Validate the Expression was Solved

You may solve some expressions before all values are bound. For example, the expression `#[vars.myVar]` does not require the `attributes`, `payload`, no `authentication` to be solved. 

After one of the binding methods is called, you can confirm the expression was completely solved by calling the method:

[source,rust]
----
evaluator.is_ready() method.
----

== See Also

* xref:policies-pdk-configure-features.adoc[]