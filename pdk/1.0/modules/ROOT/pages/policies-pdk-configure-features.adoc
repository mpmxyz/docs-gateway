= Implementing Your Custom Policy Features in Rust
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

The following pages provide Rust code examples that complete various policy tasks. Implement the Rust code for your policy in the `src/lib.rs` file.

The code examples assume you have some prior knowledge of the Rust Programming Language. For more information about programming in Rust, see:

* https://doc.rust-lang.org/book/[The Rust Programming Language Documentation ^]
* https://rust-lang-nursery.github.io/rust-cookbook/intro.html[Rust Cookbook ^]

== Before You Begin

* xref:policies-pdk-create-project.adoc[Create a New Project]
* xref:policies-pdk-create-schema-definition.adoc[Define a Schema Definition]
+
NOTE: You may need to add or redefine configuration parameters while implementing your policy. 

* Review <<policy-template>> and <<wrapped-functions>> before adding additional features.

== Additional Features

PDK provides code examples for the following policy features. Review <<policy-template>> and <<wrapped-functions>> before adding the additional features:

* xref:policies-pdk-configure-features-logging.adoc[Policy Logging]
* xref:policies-pdk-configure-features-headers.adoc[Read and Writing to Request Headers and Body]
* xref:policies-pdk-configure-features-inject-parameters.adoc[Inject Parameters]
* xref:policies-pdk-configure-features-share-data.adoc[Share Data Between Requests and Responses]
* xref:policies-pdk-configure-features-caching.adoc[Share Data Between Workers and Caching]
* xref:policies-pdk-configure-features-http-request.adoc[Perform an HTTP Call]
* xref:policies-pdk-configure-features-dataweave.adoc[Use DataWeave Expressions]

* xref:policies-pdk-configure-features-stop.adoc[Stop Request Execution]

[[policy-template]]
== Policy Template

PDK provides the initial `src/lib.rs` file in the policy project as a template to begin implementing your policy:

[source,Rust]
----
// Copyright 2023 Salesforce, Inc. All rights reserved.
mod generated;

use anyhow::{anyhow, Result};

use pdk::hl::*;
use pdk::logger;

use crate::generated::config::Config;

// This filter shows how to log a specific request header.
// You can extend the function and use the configurations exposed in config.rs file
async fn request_filter(request_state: RequestState, _config: &Config) {
    let headers_state = request_state.into_headers_state().await;
    let token = headers_state.handler().header("Token").unwrap_or_default();
    // Log the header value
    logger::info!("Header value: {token}");
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).map_err(|err| {
        anyhow!(
            "Failed to parse configuration '{}'. Cause: {}",
            String::from_utf8_lossy(&bytes),
            err
        )
    })?;
    let filter = on_request(|rs| request_filter(rs, &config));
    launcher.launch(filter).await?;
    Ok(())
}
----

The policy performs some simple logging. For each incoming request, the policy logs the header `token` at the `info` log level. 

The following elements configure the policy:

* `use pdk::api::hl::*;`: Imports all the components of the PDK into the `lib.rs` source code.
* `#[entrypoint]` function: Executes when the policy is applied and calls the `request_filter` function. Variables defined inside this function are avaliable while the policy is applied.
+
The `#[entrypoint]` function receives the following parameters:
+
** `Launcher`: Sets the filter functions.
** `Configuration`: Provides the configuration parameters defined in xref:policies-pdk-create-schema-definition.adoc[]. 

* `request_filter`: Executes once per every request sent to the API instance to which the policy is applied. This function implements the filtering performed by the example policy. Variables defined inside this function are available for the duration of the request.
+
The `request_filter` is an example of a wrapped function.
+
The `#[entrypoint]` function executes wrapped functions:
+
[source,Rust]
----
let filter = on_request(|rs| request_filter(rs, &config));
launcher.launch(filter).await?;
----

[[wrapped-functions]]
== Wrapped Functions

The `on_response` or `on_request` wrapper defines when the filter function executes. 

You can define custom functions other than the provided `requests_filter` and `response_filter` in the `#[entrypoint]` function. The `requests_filter` and `response_filter` are only examples.

Instead of filtering an incoming request as shown in the pervious example, you can process the outgoing response by using the `on_response` wrapper:

[source,Rust]
----
async fn response_filter(response_state: ResponseState,_config: &Config) {
    ...
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).map_err(|err| {
        anyhow!(
            "Failed to parse configuration '{}'. Cause: {}",
            String::from_utf8_lossy(&bytes),
            err
        )
    })?;
    let filter = on_response(|rs| response_filter(rs, &config));
    launcher.launch(filter).await?;
    Ok(())
}
----

NOTE: The `request_filter` function is now the `response_filter` function.

To filter both requests and responses, use bother wrappers:

[source,Rust]
----
async fn request_filter(request_state: RequestState,_config: &Config) {
    ...
}

async fn response_filter(response_state: ResponseState,_config: &Config) {
    ...
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).map_err(|err| {
        anyhow!(
            "Failed to parse configuration '{}'. Cause: {}",
            String::from_utf8_lossy(&bytes),
            err
        )
    })?;
    let filter = on_request(|rs| request_filter(rs, &config))
    .on_response(|rs| response_filter(rs, &config));
    launcher.launch(filter).await?;
    Ok(())
}
----
